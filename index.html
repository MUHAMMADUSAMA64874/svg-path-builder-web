<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Path Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #canvas {
            background-image: linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                              linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: #ffffff;
        }
        .dark #canvas {
            background-image: linear-gradient(to right, #6b7280 1px, transparent 1px),
                              linear-gradient(to bottom, #6b7280 1px, transparent 1px);
            background-color: #1f2937;
        }
        .collapsible-header {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .collapsible-content {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }
        .point, .cp1, .cp2 {
            cursor: pointer;
            stroke: transparent;
            stroke-width: 2;
            transition: stroke-width 0.2s, stroke 0.2s;
        }
        .point {
            fill: #0000ff;
        }
        .cp1, .cp2 {
            fill: #ff0000;
        }
        .dark .point {
            fill: #60a5fa;
            stroke: #ffffff;
            stroke-opacity: 0.5;
        }
        .dark .cp1, .dark .cp2 {
            fill: #f87171;
            stroke: #ffffff;
            stroke-opacity: 0.5;
        }
        .point:hover, .cp1:hover, .cp2:hover {
            stroke-width: 3;
            stroke: #000;
        }
        .dark .point:hover, .dark .cp1:hover, .dark .cp2:hover {
            stroke-width: 4;
            stroke: #ffffff;
        }
        .handle {
            stroke: #6b7280;
            stroke-dasharray: 2;
            transition: stroke-width 0.2s, stroke 0.2s;
        }
        .dark .handle {
            stroke: #9ca3af;
        }
        .handle:hover {
            stroke-width: 2;
            stroke: #10b981;
        }
        .status {
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #control-panel {
            transition: width 0.2s;
            position: relative;
        }
        #canvas-container {
            transition: transform 0.2s;
        }
        button {
            transition: transform 0.2s, background-color 0.2s;
        }
        button:hover {
            transform: scale(1.05);
        }
        #toggle-panel {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }
        .loading::after {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex h-screen p-4">
    <div id="main-container" class="flex flex-1 bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden relative">
        <div id="canvas-container" class="flex-1 relative overflow-auto">
            <svg id="canvas" class="w-full h-full" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
                <image id="background-image" x="0" y="0" width="800" height="600"/>
                <path id="path" fill="none" stroke="black" stroke-width="2"/>
                <g id="points"></g>
            </svg>
        </div>
        <div id="control-panel" class="bg-gray-50 dark:bg-gray-700 p-4 overflow-y-auto" style="width: 350px;">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">SVG Path Builder</h2>
                <button id="toggle-panel" class="bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-white p-1 rounded hover:bg-gray-400 dark:hover:bg-gray-500" title="Toggle control panel">◄</button>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Mode</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Select Mode:</label>
                    <select id="mode" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" title="Choose interaction mode">
                        <option value="add_points">Add Points</option>
                        <option value="edit_points">Edit Points</option>
                    </select>
                    <label class="block my-2 text-gray-700 dark:text-gray-200"><input type="checkbox" id="snap-to-grid" class="mr-2" checked> Snap to Grid</label>
                    <label class="block my-2 text-gray-700 dark:text-gray-200"><input type="checkbox" id="show-grid" class="mr-2" checked> Show Grid</label>
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Grid Size (px):</label>
                    <input type="number" id="grid-size" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" value="20" min="10" max="100" title="Set grid size in pixels">
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Path</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Path Data:</label>
                    <input type="text" id="path-data" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" placeholder="e.g., M100,100 C200,200 300,200 400,100" title="Enter SVG path data (M, C commands)">
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <button onclick="validatePathData()" class="bg-yellow-500 text-white p-2 rounded hover:bg-yellow-600" title="Validate path data">Validate Path</button>
                        <button id="load-path-btn" onclick="loadPathData()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Load path data into canvas">Load Path</button>
                    </div>
                    <button onclick="loadSamplePath()" class="w-full bg-blue-500 text-white p-2 rounded mt-2 hover:bg-blue-600" title="Load a sample path">Load Sample Path</button>
                    <button onclick="centerPath()" class="w-full bg-blue-500 text-white p-2 rounded mt-2 hover:bg-blue-600" title="Center path without scaling">Center Path</button>
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Path Color:</label>
                    <input type="color" id="path-color" class="w-full h-10 border rounded dark:bg-gray-600" value="#000000" title="Choose path color">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Endpoint Color:</label>
                    <input type="color" id="endpoint-color" class="w-full h-10 border rounded dark:bg-gray-600" value="#0000ff" title="Choose endpoint color">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Control Point Color:</label>
                    <input type="color" id="control-point-color" class="w-full h-10 border rounded dark:bg-gray-600" value="#ff0000" title="Choose control point color">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Handle Color:</label>
                    <input type="color" id="handle-color" class="w-full h-10 border rounded dark:bg-gray-600" value="#6b7280" title="Choose handle color">
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Text Properties</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Text Content:</label>
                    <input type="text" id="text-content" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" value="Your text here" title="Text to display along the path">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Font Size:</label>
                    <input type="number" id="font-size" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" value="36" min="1" title="Font size in pixels">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Text Color:</label>
                    <input type="color" id="text-color" class="w-full h-10 border rounded dark:bg-gray-600" value="#000000" title="Choose text color">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Letter Spacing:</label>
                    <input type="range" id="letter-spacing" class="w-full" min="-20" max="50" value="0" title="Adjust letter spacing">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Start Offset (%):</label>
                    <input type="number" id="start-offset" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" value="0" min="0" max="100" title="Text start position along path">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Animation Direction:</label>
                    <select id="animation-direction" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" title="Direction of text animation">
                        <option value="left-to-right">Left to Right</option>
                        <option value="right-to-left">Right to Left</option>
                    </select>
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Animation</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <label class="block text-sm mt-2 text-gray-700 dark:text-gray-200">Duration (seconds):</label>
                    <input type="number" id="duration" class="w-full p-2 border rounded dark:bg-gray-600 dark:text-white" value="10" min="1" title="Animation duration in seconds">
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Actions</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <button onclick="clearCanvas()" class="bg-red-500 text-white p-2 rounded hover:bg-red-600" title="Clear all points and image">Clear Canvas</button>
                        <button onclick="toggleAnimation()" class="bg-green-500 text-white p-2 rounded hover:bg-green-600" title="Start/stop text animation">Preview Animation</button>
                        <button onclick="undo()" class="bg-gray-500 text-white p-2 rounded hover:bg-gray-600" title="Undo last action (Ctrl+Z)">Undo</button>
                        <button onclick="redo()" class="bg-gray-500 text-white p-2 rounded hover:bg-gray-600" title="Redo undone action (Ctrl+Y)">Redo</button>
                    </div>
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Import/Export</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <button onclick="saveSvg()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Save SVG file (Ctrl+S)">Save SVG</button>
                        <button onclick="document.getElementById('load-svg').click()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Load SVG file">Load SVG</button>
                        <input type="file" id="load-svg" accept=".svg" class="hidden" onchange="loadSvgFile(this.files[0])">
                        <button onclick="copySvgCode()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Copy SVG code to clipboard">Copy SVG Code</button>
                        <button onclick="document.getElementById('load-image').click()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Load image for tracing">Load Image</button>
                        <input type="file" id="load-image" accept="image/*" class="hidden" onchange="loadImage(this.files[0])">
                        <button onclick="fitToCanvas()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Fit path to canvas">Fit to Canvas</button>
                        <button onclick="resetView()" class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Reset canvas zoom and scroll">Reset View</button>
                    </div>
                    <div id="image-preview" class="mt-2 hidden">
                        <p class="text-sm text-gray-700 dark:text-gray-200">Image Preview:</p>
                        <img id="image-thumbnail" class="w-24 h-24 object-contain border rounded">
                    </div>
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">SVG Code</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <textarea id="svg-code" class="w-full p-2 border rounded h-32 dark:bg-gray-600 dark:text-white" readonly title="Generated SVG code"></textarea>
                </div>
            </div>
            <div class="collapsible-section">
                <div class="collapsible-header bg-gray-200 dark:bg-gray-600 p-2 rounded flex justify-between items-center">
                    <h3 class="text-lg text-gray-800 dark:text-white">Theme</h3>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <button id="toggle-dark-mode" class="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600" title="Toggle between light and dark mode">Toggle Dark Mode</button>
                </div>
            </div>
        </div>
    </div>
    <div id="status" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded shadow-lg hidden flex items-center text-white">
        <span id="status-text"></span>
        <button onclick="this.parentElement.style.display='none'" class="ml-2 text-sm">✕</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const pathElement = document.getElementById('path');
        const pointsGroup = document.getElementById('points');
        const backgroundImage = document.getElementById('background-image');
        let points = [];
        let undoStack = [];
        let redoStack = [];
        let dragging = false;
        let selectedPointIndex = null;
        let isAnimating = false;
        let animationFrame;
        let imageDataUrl = null;
        let zoomLevel = 1;
        let gridSize = 20;
        let showGrid = true;
        let pathColor = '#000000';
        let endpointColor = '#0000ff';
        let controlPointColor = '#ff0000';
        let handleColor = '#6b7280';

        // Initialize colors
        document.getElementById('path-color').addEventListener('input', (e) => {
            pathColor = e.target.value;
            pathElement.setAttribute('stroke', pathColor);
        });
        document.getElementById('endpoint-color').addEventListener('input', (e) => {
            endpointColor = e.target.value;
            drawPath();
        });
        document.getElementById('control-point-color').addEventListener('input', (e) => {
            controlPointColor = e.target.value;
            drawPath();
        });
        document.getElementById('handle-color').addEventListener('input', (e) => {
            handleColor = e.target.value;
            drawPath();
        });

        // Initialize grid
        document.getElementById('grid-size').addEventListener('input', (e) => {
            gridSize = Math.max(10, Math.min(100, parseInt(e.target.value) || 20));
            updateGrid();
        });
        document.getElementById('show-grid').addEventListener('change', (e) => {
            showGrid = e.target.checked;
            updateGrid();
        });

        // Initialize event listeners
        initializeEventListeners();
        initializeCollapsibleSections();
        initializePanelDrag();

        function initializeEventListeners() {
            canvas.addEventListener('mousedown', onCanvasClick);
            canvas.addEventListener('mousemove', throttle(onCanvasDrag, 16));
            canvas.addEventListener('mouseup', onCanvasRelease);
            canvas.addEventListener('mouseleave', onCanvasRelease);
            canvas.addEventListener('contextmenu', onCanvasRightClick);
            canvas.addEventListener('wheel', onCanvasWheel);
            document.querySelectorAll('#text-content, #font-size, #text-color, #letter-spacing, #start-offset, #animation-direction, #duration').forEach(input => {
                input.addEventListener('input', updatePreview);
            });
            document.getElementById('mode').addEventListener('change', () => showStatus('✅ Mode changed!', 'bg-green-500'));
            document.getElementById('snap-to-grid').addEventListener('change', () => drawPath());
            document.addEventListener('keydown', handleKeydown);
            document.getElementById('toggle-panel').addEventListener('click', toggleControlPanel);
            document.getElementById('toggle-dark-mode').addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                updateGrid();
                drawPath();
                showStatus('✅ Theme toggled!', 'bg-green-500');
            });
        }

        function throttle(func, delay) {
            let lastCall = 0;
            return function (...args) {
                const now = performance.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return func(...args);
                }
            };
        }

        function initializeCollapsibleSections() {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const isOpen = content.style.maxHeight;
                    document.querySelectorAll('.collapsible-content').forEach(c => c.style.maxHeight = null);
                    document.querySelectorAll('.collapsible-header span').forEach(s => s.textContent = '▼');
                    if (!isOpen) {
                        content.style.maxHeight = `${content.scrollHeight}px`;
                        header.querySelector('span').textContent = '▲';
                    }
                });
                if (header === document.querySelector('.collapsible-header')) {
                    header.nextElementSibling.style.maxHeight = `${header.nextElementSibling.scrollHeight}px`;
                    header.querySelector('span').textContent = '▲';
                }
            });
        }

        function initializePanelDrag() {
            const panel = document.getElementById('control-panel');
            let isDragging = false;
            let startX, startWidth;
            panel.addEventListener('mousedown', e => {
                if (e.offsetX < 5 && panel.style.width !== '0px') {
                    isDragging = true;
                    startX = e.clientX;
                    startWidth = panel.offsetWidth;
                }
            });
            document.addEventListener('mousemove', e => {
                if (isDragging) {
                    const newWidth = startWidth - (e.clientX - startX);
                    panel.style.width = `${Math.max(200, Math.min(newWidth, 500))}px`;
                    updateCollapsibleHeights();
                }
            });
            document.addEventListener('mouseup', () => isDragging = false);
        }

        function updateCollapsibleHeights() {
            document.querySelectorAll('.collapsible-content').forEach(content => {
                if (content.style.maxHeight) {
                    content.style.maxHeight = `${content.scrollHeight}px`;
                }
            });
        }

        function toggleControlPanel() {
            const panel = document.getElementById('control-panel');
            const toggleBtn = document.getElementById('toggle-panel');
            if (panel.style.width === '0px') {
                panel.style.width = '350px';
                toggleBtn.textContent = '◄';
                updateCollapsibleHeights();
            } else {
                panel.style.width = '0px';
                toggleBtn.textContent = '►';
            }
            toggleBtn.title = panel.style.width === '0px' ? 'Show control panel' : 'Hide control panel';
        }

        function updateGrid() {
            if (showGrid) {
                const color = document.documentElement.classList.contains('dark') ? '#6b7280' : '#e5e7eb';
                canvas.style.backgroundImage = `linear-gradient(to right, ${color} 1px, transparent 1px), linear-gradient(to bottom, ${color} 1px, transparent 1px)`;
                canvas.style.backgroundSize = `${gridSize}px ${gridSize}px`;
            } else {
                canvas.style.backgroundImage = 'none';
            }
        }

        function handleKeydown(event) {
            if (event.ctrlKey) {
                switch (event.key.toLowerCase()) {
                    case 'z':
                        event.preventDefault();
                        undo();
                        break;
                    case 'y':
                        event.preventDefault();
                        redo();
                        break;
                    case 's':
                        event.preventDefault();
                        saveSvg();
                        break;
                }
            }
            if (event.target.id === 'mode' && ['ArrowUp', 'ArrowDown'].includes(event.key)) {
                const select = document.getElementById('mode');
                const options = Array.from(select.options);
                const currentIndex = select.selectedIndex;
                const newIndex = event.key === 'ArrowUp' ?
                    Math.max(0, currentIndex - 1) :
                    Math.min(options.length - 1, currentIndex + 1);
                select.selectedIndex = newIndex;
                select.dispatchEvent(new Event('change'));
            }
        }

        function getCanvasPoint(event) {
            const rect = canvas.getBoundingClientRect();
            const container = document.getElementById('canvas-container');
            const x = ((event.clientX - rect.left + container.scrollLeft) * (canvas.viewBox.baseVal.width / rect.width)) / zoomLevel;
            const y = ((event.clientY - rect.top + container.scrollTop) * (canvas.viewBox.baseVal.height / rect.height)) / zoomLevel;
            const snap = document.getElementById('snap-to-grid').checked;
            return {
                x: snap ? Math.round(Math.max(0, Math.min(x, 800)) / gridSize) * gridSize : Math.max(0, Math.min(x, 800)),
                y: snap ? Math.round(Math.max(0, Math.min(y, 600)) / gridSize) * gridSize : Math.max(0, Math.min(y, 600))
            };
        }

        function onCanvasWheel(event) {
            if (event.ctrlKey) {
                event.preventDefault();
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                zoomLevel = Math.max(0.5, Math.min(zoomLevel + delta, 2));
                document.getElementById('canvas-container').style.transform = `scale(${zoomLevel})`;
                showStatus(`✅ Zoom: ${Math.round(zoomLevel * 100)}%`, 'bg-green-500');
            }
        }

        function saveState() {
            undoStack.push(JSON.stringify(points));
            redoStack = [];
            if (undoStack.length > 50) undoStack.shift();
        }

        function undo() {
            if (undoStack.length) {
                redoStack.push(JSON.stringify(points));
                points = JSON.parse(undoStack.pop());
                drawPath();
                showStatus('✅ Undo successful!', 'bg-green-500');
            }
        }

        function redo() {
            if (redoStack.length) {
                undoStack.push(JSON.stringify(points));
                points = JSON.parse(redoStack.pop());
                drawPath();
                showStatus('✅ Redo successful!', 'bg-green-500');
            }
        }

        function onCanvasClick(event) {
            event.preventDefault();
            const mode = document.getElementById('mode').value;
            const { x, y } = getCanvasPoint(event);
            
            if (mode === 'add_points') {
                saveState();
                if (!points.length) {
                    points.push({ type: 'M', x, y });
                } else {
                    const last = getPreviousEndpoint(points.length);
                    const cp1_x = last.x + (x - last.x) / 3;
                    const cp1_y = last.y + (y - last.y) / 3;
                    const cp2_x = last.x + 2 * (x - last.x) / 3;
                    const cp2_y = last.y + 2 * (x - last.y) / 3;
                    points.push({ type: 'C', cp1_x, cp1_y, cp2_x, cp2_y, x, y });
                }
                drawPath();
            } else if (mode === 'edit_points') {
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    if (p.type === 'M' && Math.hypot(x - p.x, y - p.y) < 10 / zoomLevel) {
                        selectedPointIndex = [i, 0];
                        dragging = true;
                        return;
                    } else if (p.type === 'C') {
                        if (Math.hypot(x - p.cp1_x, y - p.cp1_y) < 10 / zoomLevel) {
                            selectedPointIndex = [i, 1];
                            dragging = true;
                            return;
                        }
                        if (Math.hypot(x - p.cp2_x, y - p.cp2_y) < 10 / zoomLevel) {
                            selectedPointIndex = [i, 2];
                            dragging = true;
                            return;
                        }
                        if (Math.hypot(x - p.x, y - p.y) < 10 / zoomLevel) {
                            selectedPointIndex = [i, 3];
                            dragging = true;
                            return;
                        }
                    }
                }
            }
        }

        function onCanvasRightClick(event) {
            event.preventDefault();
            if (document.getElementById('mode').value !== 'edit_points') return;
            const { x, y } = getCanvasPoint(event);
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                if (p.type === 'M' && Math.hypot(x - p.x, y - p.y) < 10 / zoomLevel) {
                    saveState();
                    points.splice(i, 1);
                    drawPath();
                    showStatus('✅ Point deleted!', 'bg-green-500');
                    return;
                } else if (p.type === 'C' && Math.hypot(x - p.x, y - p.y) < 10 / zoomLevel) {
                    saveState();
                    points.splice(i, 1);
                    drawPath();
                    showStatus('✅ Point deleted!', 'bg-green-500');
                    return;
                }
            }
        }

        function onCanvasDrag(event) {
            if (!dragging || !selectedPointIndex) return;
            const { x, y } = getCanvasPoint(event);
            const [idx, type] = selectedPointIndex;
            saveState();
            if (points[idx].type === 'M') {
                points[idx].x = x;
                points[idx].y = y;
            } else if (points[idx].type === 'C') {
                if (type === 1) {
                    points[idx].cp1_x = x;
                    points[idx].cp1_y = y;
                } else if (type === 2) {
                    points[idx].cp2_x = x;
                    points[idx].cp2_y = y;
                } else if (type === 3) {
                    points[idx].x = x;
                    points[idx].y = y;
                }
            }
            drawPath();
        }

        function onCanvasRelease() {
            dragging = false;
            selectedPointIndex = null;
        }

        function getPreviousEndpoint(index) {
            if (index <= 0) return { x: 0, y: 0 };
            const prev = points[index - 1];
            return prev.type === 'M' ? { x: prev.x, y: prev.y } : { x: prev.x, y: prev.y };
        }

        function drawPath() {
            pointsGroup.innerHTML = '';
            let pathData = '';
            if (points.length && points[0].type === 'M') {
                pathData = `M${points[0].x},${points[0].y}`;
                addPointElement(0, points[0].x, points[0].y, endpointColor, 'point', 'M0');
            }
            for (let i = 1; i < points.length; i++) {
                if (points[i].type === 'C') {
                    const prev = getPreviousEndpoint(i);
                    pathData += ` C${points[i].cp1_x},${points[i].cp1_y} ${points[i].cp2_x},${points[i].cp2_y} ${points[i].x},${points[i].y}`;
                    addPointElement(i, points[i].cp1_x, points[i].cp1_y, controlPointColor, 'cp1', `CP1${i}`);
                    addPointElement(i, points[i].cp2_x, points[i].cp2_y, controlPointColor, 'cp2', `CP2${i}`);
                    addPointElement(i, points[i].x, points[i].y, endpointColor, 'point', `P${i}`);
                    addHandleElement(prev.x, prev.y, points[i].cp1_x, points[i].cp1_y);
                    addHandleElement(points[i].x, points[i].y, points[i].cp2_x, points[i].cp2_y);
                }
            }
            pathElement.setAttribute('d', pathData);
            updatePreview();

            function addPointElement(index, x, y, fill, className, label) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', className === 'point' ? 5 : 4);
                circle.setAttribute('fill', fill);
                circle.setAttribute('class', className);
                pointsGroup.appendChild(circle);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y - 15);
                text.setAttribute('font-size', '12');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', document.documentElement.classList.contains('dark') ? '#ffffff' : '#000000');
                text.textContent = label;
                pointsGroup.appendChild(text);
            }

            function addHandleElement(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', handleColor);
                line.setAttribute('class', 'handle');
                pointsGroup.appendChild(line);
            }
        }

        function samplePathPoints(numPoints) {
            const pathPoints = [];
            if (!points.length) return pathPoints;
            if (points[0].type === 'M') {
                pathPoints.push({ x: points[0].x, y: points[0].y });
            }
            for (let i = 1; i < points.length; i++) {
                if (points[i].type === 'C') {
                    const prev = getPreviousEndpoint(i);
                    const pointsPerSegment = numPoints / Math.max(1, points.length - 1);
                    for (let j = 1; j <= pointsPerSegment; j++) {
                        const t = j / pointsPerSegment;
                        const x = (1-t)**3 * prev.x + 3*(1-t)**2*t * points[i].cp1_x + 3*(1-t)*t**2 * points[i].cp2_x + t**3 * points[i].x;
                        const y = (1-t)**3 * prev.y + 3*(1-t)**2*t * points[i].cp1_y + 3*(1-t)*t**2 * points[i].cp2_y + t**3 * points[i].y;
                        pathPoints.push({ x, y });
                    }
                }
            }
            return pathPoints;
        }

        function updatePreview() {
            if (isAnimating) return;
            const textContent = sanitizeInput(document.getElementById('text-content').value);
            const fontSize = Math.max(1, parseInt(document.getElementById('font-size').value) || 36);
            const textColor = document.getElementById('text-color').value;
            const letterSpacing = parseInt(document.getElementById('letter-spacing').value) || 0;
            const startOffset = Math.max(0, Math.min(100, parseFloat(document.getElementById('start-offset').value) || 0));
            if (!points.length || !textContent) {
                generateSvg();
                return;
            }
            pointsGroup.querySelectorAll('.text-preview').forEach(el => el.remove());
            const pathPoints = samplePathPoints(200);
            if (!pathPoints.length) {
                generateSvg();
                return;
            }
            const startOffsetIdx = Math.max(0, Math.min(Math.floor(pathPoints.length * startOffset / 100), pathPoints.length - 1));
            const charWidth = fontSize * 0.6;
            let currentPos = startOffsetIdx;
            for (const char of textContent) {
                if (currentPos >= pathPoints.length) break;
                const { x, y } = pathPoints[currentPos];
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('fill', textColor);
                text.setAttribute('font-size', fontSize);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('class', 'text-preview');
                text.textContent = char;
                pointsGroup.appendChild(text);
                currentPos += Math.floor(charWidth) + letterSpacing;
            }
            generateSvg();
        }

        function generateSvg() {
            if (!points.length) {
                document.getElementById('svg-code').value = 'No path defined yet.';
                return;
            }
            let pathData = '';
            for (const p of points) {
                if (p.type === 'M') {
                    pathData += `M${p.x.toFixed(2)},${p.y.toFixed(2)}`;
                } else if (p.type === 'C') {
                    pathData += `C${p.cp1_x.toFixed(2)},${p.cp1_y.toFixed(2)} ${p.cp2_x.toFixed(2)},${p.cp2_y.toFixed(2)} ${p.x.toFixed(2)},${p.y.toFixed(2)}`;
                }
            }
            const allX = points.flatMap(p => p.type === 'M' ? [p.x] : [p.cp1_x, p.cp2_x, p.x]).filter(x => x !== undefined);
            const allY = points.flatMap(p => p.type === 'M' ? [p.y] : [p.cp1_y, p.cp2_y, p.y]).filter(y => y !== undefined);
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);
            const viewBox = `${(minX - 50).toFixed(2)} ${(minY - 50).toFixed(2)} ${(maxX - minX + 100).toFixed(2)} ${(maxY - minY + 100).toFixed(2)}`;
            const direction = document.getElementById('animation-direction').value;
            const animateFrom = direction === 'left-to-right' ? '-100%' : '100%';
            const animateTo = direction === 'left-to-right' ? '100%' : '-100%';
            const svgCode = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" width="100%" height="100%">
    <path id="curve" d="${pathData}" fill="none" stroke="${pathColor}" stroke-width="2"/>
    <text font-size="${Math.max(1, parseInt(document.getElementById('font-size').value) || 36)}" 
          fill="${document.getElementById('text-color').value}" 
          letter-spacing="${parseInt(document.getElementById('letter-spacing').value) || 0}px">
        <textPath href="#curve" startOffset="${Math.max(0, Math.min(100, parseFloat(document.getElementById('start-offset').value) || 0))}%">
            ${sanitizeInput(document.getElementById('text-content').value)}
            <animate attributeName="startOffset" from="${animateFrom}" to="${animateTo}" 
                    dur="${Math.max(1, parseFloat(document.getElementById('duration').value) || 10)}s" repeatCount="indefinite"/>
        </textPath>
    </text>
</svg>`.trim();
            document.getElementById('svg-code').value = svgCode;
        }

        function validatePathData() {
            const pathString = sanitizeInput(document.getElementById('path-data').value.trim());
            if (!pathString) {
                showStatus('❌ Path data is empty!', 'bg-red-500');
                return;
            }
            try {
                parsePathData(pathString);
                showStatus('✅ Path data is valid!', 'bg-green-500');
            } catch (error) {
                showStatus(`❌ Invalid path: ${error.message}`, 'bg-red-500');
            }
        }

        function loadPathData() {
            const pathString = sanitizeInput(document.getElementById('path-data').value.trim());
            const loadBtn = document.getElementById('load-path-btn');
            if (!pathString) {
                showStatus('❌ Path data is empty!', 'bg-red-500');
                return;
            }
            loadBtn.classList.add('loading');
            loadBtn.disabled = true;
            setTimeout(() => {
                try {
                    saveState();
                    points = parsePathData(pathString);
                    if (!points.length) throw new Error('No valid path commands found');
                    normalizePath();
                    drawPath();
                    showStatus('✅ Path loaded successfully!', 'bg-green-500');
                } catch (error) {
                    showStatus(`❌ Failed to load path: ${error.message}`, 'bg-red-500');
                } finally {
                    loadBtn.classList.remove('loading');
                    loadBtn.disabled = false;
                }
            }, 100);
        }

        function parsePathData(pathString) {
            const points = [];
            let currentX = 0, currentY = 0;
            const tokens = pathString
                .replace(/[, ]+/g, ' ')
                .replace(/([MmCcZz])/g, ' $1 ')
                .trim()
                .split(/\s+/)
                .filter(t => t)
                .map(t => t.match(/[MmCcZz]/) ? t : parseFloat(t));
            
            let i = 0;
            while (i < tokens.length) {
                const cmd = tokens[i];
                if (typeof cmd !== 'string') throw new Error(`Invalid command at position ${i}`);
                i++;
                if (cmd.toLowerCase() === 'm') {
                    if (i + 1 >= tokens.length) throw new Error('Incomplete M/m command');
                    const x = tokens[i++];
                    const y = tokens[i++];
                    if (isNaN(x) || isNaN(y)) throw new Error('Invalid coordinates in M/m command');
                    const absX = cmd === 'm' ? currentX + x : x;
                    const absY = cmd === 'm' ? currentY + y : y;
                    points.push({ type: 'M', x: absX, y: absY });
                    currentX = absX;
                    currentY = absY;
                    while (i < tokens.length && typeof tokens[i] === 'number') {
                        if (i + 1 >= tokens.length) throw new Error('Incomplete implicit line-to command');
                        const x = tokens[i++];
                        const y = tokens[i++];
                        if (isNaN(x) || isNaN(y)) throw new Error('Invalid coordinates in implicit line-to');
                        const absX = cmd === 'm' ? currentX + x : x;
                        const absY = cmd === 'm' ? currentY + y : y;
                        const lastX = currentX, lastY = currentY;
                        const cp1_x = lastX + (absX - lastX) / 3;
                        const cp1_y = lastY + (absY - lastY) / 3;
                        const cp2_x = lastX + 2 * (absX - lastX) / 3;
                        const cp2_y = lastY + 2 * (absY - lastY) / 3;
                        points.push({ type: 'C', cp1_x, cp1_y, cp2_x, cp2_y, x: absX, y: absY });
                        currentX = absX;
                        currentY = absY;
                    }
                } else if (cmd.toLowerCase() === 'c') {
                    while (i < tokens.length && typeof tokens[i] === 'number') {
                        if (i + 5 >= tokens.length) throw new Error('Incomplete C/c command');
                        const cp1_x = tokens[i++];
                        const cp1_y = tokens[i++];
                        const cp2_x = tokens[i++];
                        const cp2_y = tokens[i++];
                        const x = tokens[i++];
                        const y = tokens[i++];
                        if ([cp1_x, cp1_y, cp2_x, cp2_y, x, y].some(v => isNaN(v))) throw new Error('Invalid coordinates in C/c command');
                        const absCp1_x = cmd === 'c' ? currentX + cp1_x : cp1_x;
                        const absCp1_y = cmd === 'c' ? currentY + cp1_y : cp1_y;
                        const absCp2_x = cmd === 'c' ? currentX + cp2_x : cp2_x;
                        const absCp2_y = cmd === 'c' ? currentY + cp2_y : cp2_y;
                        const absX = cmd === 'c' ? currentX + x : x;
                        const absY = cmd === 'c' ? currentY + y : y;
                        points.push({ type: 'C', cp1_x: absCp1_x, cp1_y: absCp1_y, cp2_x: absCp2_x, cp2_y: absCp2_y, x: absX, y: absY });
                        currentX = absX;
                        currentY = absY;
                    }
                } else if (cmd.toLowerCase() === 'z') {
                    // Skip for now
                } else {
                    throw new Error(`Unsupported command: ${cmd}`);
                }
            }
            return points;
        }

        function normalizePath() {
            if (!points.length) return;
            const allX = points.flatMap(p => p.type === 'M' ? [p.x] : [p.cp1_x, p.cp2_x, p.x]).filter(x => x !== undefined);
            const allY = points.flatMap(p => p.type === 'M' ? [p.y] : [p.cp1_y, p.cp2_y, p.y]).filter(y => y !== undefined);
            if (!allX.length || !allY.length) return;
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const padding = 50;
            const widthScale = (800 - 2 * padding) / width;
            const heightScale = (600 - 2 * padding) / height;
            const scale = Math.min(widthScale, heightScale);
            const offsetX = (800 - width * scale) / 2 - minX * scale;
            const offsetY = (600 - height * scale) / 2 - minY * scale;
            points = points.map(p => {
                if (p.type === 'M') {
                    return { type: 'M', x: p.x * scale + offsetX, y: p.y * scale + offsetY };
                } else {
                    return {
                        type: 'C',
                        cp1_x: p.cp1_x * scale + offsetX,
                        cp1_y: p.cp1_y * scale + offsetY,
                        cp2_x: p.cp2_x * scale + offsetX,
                        cp2_y: p.cp2_y * scale + offsetY,
                        x: p.x * scale + offsetX,
                        y: p.y * scale + offsetY
                    };
                }
            });
        }

        function centerPath() {
            if (!points.length) return;
            saveState();
            const allX = points.flatMap(p => p.type === 'M' ? [p.x] : [p.cp1_x, p.cp2_x, p.x]).filter(x => x !== undefined);
            const allY = points.flatMap(p => p.type === 'M' ? [p.y] : [p.cp1_y, p.cp2_y, p.y]).filter(y => y !== undefined);
            if (!allX.length || !allY.length) return;
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);
            const offsetX = (800 - (maxX - minX)) / 2 - minX;
            const offsetY = (600 - (maxY - minY)) / 2 - minY;
            points = points.map(p => {
                if (p.type === 'M') {
                    return { type: 'M', x: p.x + offsetX, y: p.y + offsetY };
                } else {
                    return {
                        type: 'C',
                        cp1_x: p.cp1_x + offsetX,
                        cp1_y: p.cp1_y + offsetY,
                        cp2_x: p.cp2_x + offsetX,
                        cp2_y: p.cp2_y + offsetY,
                        x: p.x + offsetX,
                        y: p.y + offsetY
                    };
                }
            });
            drawPath();
            showStatus('✅ Path centered!', 'bg-green-500');
        }

        function fitToCanvas() {
            saveState();
            normalizePath();
            drawPath();
            showStatus('✅ Path fitted to canvas!', 'bg-green-500');
        }

        function resetView() {
            const container = document.getElementById('canvas-container');
            container.scrollLeft = 0;
            container.scrollTop = 0;
            zoomLevel = 1;
            container.style.transform = 'scale(1)';
            showStatus('✅ View reset!', 'bg-green-500');
        }

        function clearCanvas() {
            if (!confirm('Are you sure you want to clear the canvas? This will remove all points and the image.')) return;
            saveState();
            points = [];
            backgroundImage.setAttribute('href', '');
            imageDataUrl = null;
            document.getElementById('image-preview').classList.add('hidden');
            pathElement.setAttribute('d', '');
            pointsGroup.innerHTML = '';
            isAnimating = false;
            cancelAnimationFrame(animationFrame);
            document.getElementById('svg-code').value = '';
            updatePreview();
            showStatus('✅ Canvas cleared!', 'bg-green-500');
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animateText();
                showStatus('✅ Animation started!', 'bg-green-500');
            } else {
                cancelAnimationFrame(animationFrame);
                drawPath();
                showStatus('✅ Animation stopped!', 'bg-green-500');
            }
        }

        function animateText() {
            if (!isAnimating) return;
            const textContent = sanitizeInput(document.getElementById('text-content').value);
            const fontSize = Math.max(1, parseInt(document.getElementById('font-size').value) || 36);
            const textColor = document.getElementById('text-color').value;
            const letterSpacing = parseInt(document.getElementById('letter-spacing').value) || 0;
            const duration = Math.max(1, parseFloat(document.getElementById('duration').value) || 10);
            const direction = document.getElementById('animation-direction').value;
            if (!textContent || !points.length) {
                animationFrame = requestAnimationFrame(animateText);
                return;
            }
            const pathPoints = samplePathPoints(200);
            if (!pathPoints.length) {
                animationFrame = requestAnimationFrame(animateText);
                return;
            }
            pointsGroup.querySelectorAll('.text-preview').forEach(el => el.remove());
            const currentTime = performance.now() / 1000;
            const progress = (currentTime % duration) / duration;
            const startOffset = direction === 'left-to-right' ?
                Math.floor(pathPoints.length * progress) :
                Math.floor(pathPoints.length * (1 - progress));
            const charWidth = fontSize * 0.6;
            let currentPos = startOffset;
            for (const char of textContent) {
                if (currentPos >= pathPoints.length || currentPos < 0) continue;
                const { x, y } = pathPoints[currentPos];
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('fill', textColor);
                text.setAttribute('font-size', fontSize);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('class', 'text-preview');
                text.textContent = char;
                pointsGroup.appendChild(text);
                currentPos += Math.floor(charWidth) + letterSpacing;
            }
            animationFrame = requestAnimationFrame(animateText);
        }

        function copySvgCode() {
            const svgCode = document.getElementById('svg-code').value.trim();
            if (svgCode && !svgCode.includes('No path defined') && !svgCode.includes('Error')) {
                navigator.clipboard.writeText(svgCode).then(() => {
                    showStatus('✅ SVG code copied to clipboard!', 'bg-green-500');
                }).catch(err => {
                    showStatus(`❌ Failed to copy SVG code: ${err}`, 'bg-red-500');
                });
            } else {
                showStatus('❌ No valid SVG code to copy!', 'bg-red-500');
            }
        }

        function saveSvg() {
            const svgCode = document.getElementById('svg-code').value.trim();
            if (!svgCode || svgCode.includes('No path defined')) {
                showStatus('❌ No valid SVG to save!', 'bg-red-500');
                return;
            }
            const blob = new Blob([svgCode], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'path.svg';
            a.click();
            URL.revokeObjectURL(url);
            showStatus('✅ SVG saved successfully!', 'bg-green-500');
        }

        function loadSvgFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                const content = reader.result;
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'image/svg+xml');
                const path = doc.querySelector('path');
                if (path) {
                    const pathData = path.getAttribute('d');
                    document.getElementById('path-data').value = pathData;
                    loadPathData();
                } else {
                    showStatus('❌ No valid path data in SVG file', 'bg-red-500');
                }
            };
            reader.readAsText(file);
        }

        function loadImage(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                const img = new Image();
                img.onload = () => {
                    const scale = Math.min(800 / img.width, 600 / img.height);
                    const newWidth = img.width * scale;
                    const newHeight = img.height * scale;
                    backgroundImage.setAttribute('width', newWidth);
                    backgroundImage.setAttribute('height', newHeight);
                    backgroundImage.setAttribute('href', reader.result);
                    imageDataUrl = reader.result;
                    const thumbnail = document.getElementById('image-thumbnail');
                    thumbnail.src = reader.result;
                    document.getElementById('image-preview').classList.remove('hidden');
                    drawPath();
                    showStatus('✅ Image loaded successfully!', 'bg-green-500');
                };
                img.src = reader.result;
            };
            reader.readAsDataURL(file);
        }

        function loadSamplePath() {
            document.getElementById('path-data').value = 'M63,766 C55,25 776,782 775,38';
            document.getElementById('letter-spacing').value = -2;
            document.getElementById('font-size').value = 18;
            document.getElementById('text-content').value = 'Thank You 😉';
            loadPathData();
            updatePreview();
            showStatus('✅ Sample path loaded!', 'bg-green-500');
        }

        function sanitizeInput(input) {
            return input.replace(/[<>]/g, '');
        }

        function showStatus(message, bgColor) {
            const status = document.getElementById('status');
            const statusText = document.getElementById('status-text');
            statusText.innerHTML = message;
            status.className = `fixed bottom-4 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded shadow-lg text-white ${bgColor} status flex items-center`;
            status.style.display = 'flex';
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
    </script>
</body>
</html>
